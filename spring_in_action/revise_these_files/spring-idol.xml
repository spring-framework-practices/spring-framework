<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:p="http://www.springframework.org/schema/p"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:util="http://www.springframework.org/schema/util"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
	   http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd">


    <!--=============================================================================================================-->
    <!--===================================== Внедрение через конструкторы ==========================================-->
    <!--=============================================================================================================-->
    <!--<start id="duke_bean" />-->
    <bean id="duke" class="springidol.Juggler"/>
    <!--<end id="duke_bean" />-->

    <!--<start id="duke_bean" />-->
    <bean id="duke_15beanBags" class="springidol.Juggler">
        <constructor-arg value="15"/>
    </bean>
    <!--<end id="duke_bean" />-->


    <!--=============================================================================================================-->
    <!--================================== Внедрение ссылок через конструкторы ======================================-->
    <!--=============================================================================================================-->
    <!--<start id="sonnet29_bean" />-->
    <bean id="sonnet29" class="springidol.Sonnet29"/>
    <!--<end id="sonnet29_bean" />-->

    <!--<start id="poeticduke_bean" />-->
    <bean id="poeticDuke" class="springidol.PoeticJuggler">
        <constructor-arg value="15"/>
        <constructor-arg ref="sonnet29"/>
    </bean>
    <!--<end id="poeticduke_bean" />-->


    <!--=============================================================================================================-->
    <!--=========================== Создание компонентов с помощью фабричных методов ================================-->
    <!--=============================================================================================================-->
    <!--==== Проницательный читатель заметит, что понятие единичных компонентов ограничено областью действия     ====-->
    <!--==== контекста Spring. В отличие от истинных классов-одиночек, гарантирующих существование               ====-->
    <!--==== единственного экземпляра на каждый загрузчик классов(classloader), для единичных компонентов        ====-->
    <!--==== в Spring гарантируется только наличие единственного экземпляра компонента в контексте приложения    ====-->
    <!--==== ничто не мешает создать экземпляр того же класса традиционным способом или даже создать несколько   ====-->
    <!--==== объявлений <bean> для одного и того же класса.                                                      ====-->

    <bean id="theStage" class="springidol.Stage" factory-method="getInstance"/>
    <bean id="theStage2" class="springidol.Stage" factory-method="getInstance"/>
    <bean id="theStage3" class="springidol.Stage" factory-method="getInstance" scope="prototype"/>


    <!--=============================================================================================================-->
    <!--=================== получить уникальный экземпляр компонента при каждом обращении ===========================-->
    <!--=============================================================================================================-->
    <!--==== По умолчанию все компоненты Spring единичны. Когда контейнер передает компонент (либо через         ====-->
    <!--==== связывание, либо как результат вызова метода контейнера getBean()), всегда будет передан тот же     ====-->
    <!--==== самый экземпляр компонента. Однако иногда бывает необходимо получить уникальный экземпляр           ====-->
    <!--==== компонента при каждом обращении. Чтобы заставить фреймворк Spring создавать новый экземпляр при     ====-->
    <!--==== каждом обращении, в объявление компонента следует добавить атрибут scope со значением prototype.    ====-->
    <!--==== Например, представьте, что билеты на выступления объявляются как компоненты Spring:                 ====-->
    <!--====                                                                                                     ====-->
    <!--==== singleton: В каждом контейнере Spring может быть создан только один компонент (по умолчанию)        ====-->
    <!--==== prototype: Позволяет создавать произвольное количество компонентов (по одному на каждое обращение)  ====-->
    <!--==== request: Область действия компонента ограничивается HTTP-запросом. Может применяться только в       ====-->
    <!--====          веб-приложениях Spring (например, использующих Spring MVC)                                 ====-->
    <!--==== session: Область действия компонента ограничивается HTTP-сеансом. Может применяться только в        ====-->
    <!--====          веб-приложениях Spring (например, использующих Spring MVC)                                 ====-->
    <!--==== global-session: Область действия компонента ограничивается глобальным HTTP-сеансом. Может           ====-->
    <!--====                 применяться только в портлетах                                                      ====-->

    <bean id="ticketPrototype" class="springidol.Ticket" scope="prototype"/>
    <bean id="ticketSingelton" class="springidol.Ticket" scope="singleton"/>


    <!--=============================================================================================================-->
    <!--============================= Инициализация и уничтожение компонентов =======================================-->
    <!--=============================================================================================================-->
    <!--==== Чтобы определить методы, вызываемые при создании и уничтожении компонента, просто добавьте в        ====-->
    <!--==== элемент <bean> атрибуты init-method и/или destroy-method . Атрибут init-method определяет метод,    ====-->
    <!--==== вызываемый сразу после создания экземпляра компонента. Аналогично атрибут destroy-method определяет ====-->
    <!--==== метод, вызываемый непосредственно перед удалением компонента из контейнера.                         ====-->
    <!--====                                                                                                     ====-->
    <!--==== Интерфейсы InitializingBean и DisposableBean. Фреймворк Spring обеспечивает альтернативный способ   ====-->
    <!--==== определения методов инициализации и уничтожения компонентов – реализовать в классе компонента       ====-->
    <!--==== интерфейсы InitializingBean и DisposableBean. Компонентам, реализующим эти интерфейсы,              ====-->
    <!--==== предоставляется возможность управлять этапами своего жизненного цикла, и они обрабатываются         ====-->
    <!--==== фреймворком Spring особым образом. Интерфейс InitializingBean объявляет метод afterPropertiesSet(), ====-->
    <!--==== который играет роль метода инициализации. А интерфейс DisposableBean объявляет метод destroy(),     ====-->
    <!--==== который вызывается перед удалением компонента из контекста приложения. Главным преимуществом        ====-->
    <!--==== использования этих интерфейсов управления жизненным циклом является автоматическое определение      ====-->
    <!--==== контейнером Spring компонентов, реализующих эти интерфейсы, без каких-либо внешних настроек.        ====-->
    <!--==== А недостаток состоит в образовании тесной связи между прикладными компонентами и Spring API.        ====-->
    <!--==== Именно по этой причине для реализации операций инициализации и уничтожения компонентов я ре-        ====-->
    <!--==== комендую использовать атрибуты init-method и destroy-method. Единственное, где могут пригодиться    ====-->
    <!--==== интерфейсы управления жизненным циклом, – при разработке компонентов собственного фреймворка,       ====-->
    <!--==== которые будут использоваться исключительно в контейнере Spring.                                     ====-->

    <!--<bean id="auditorium"-->
    <!--class="com.springinaction.springidol.Auditorium"-->
    <!--init-method="turnOnLights"-->
    <!--destroy-method="turnOffLights"/>-->


    <!--=============================================================================================================-->
    <!--================================ Методы инициализации и уничтоженияпо умолчанию =============================-->
    <!--=============================================================================================================-->
    <!--==== Если в файле определения контекста необходимо определить множество компонентов с методами           ====-->
    <!--==== инициализации или уничтожения , имеющими одинаковые имена, можно не объявлять атрибуты              ====-->
    <!--==== init-method и destroy-method для каждого отдельного компонента, а добавить атрибуты                 ====-->
    <!--==== default-init-method и default-destroy-method в элемент <beans> :                                    ====-->
    <!--==== <?xml version="1.0" encoding="UTF-8"?>                                                              ====-->
    <!--==== <beans xmlns="http://www.springframework.org/schema/beans"                                          ====-->
    <!--====     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"                                           ====-->
    <!--====     xsi:schemaLocation="http://www.springframework.org/schema/beans                                 ====-->
    <!--====     http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"                               ====-->
    <!--====     default-init-method="turnOnLights"                                                              ====-->
    <!--====     default-destroy-method="turnOffLights"> ...                                                     ====-->
    <!--==== </beans>                                                                                            ====-->
    <!--====                                                                                                     ====-->
    <!--==== Атрибут default-init-method определяет метод инициализации для всех компонентов в данном            ====-->
    <!--==== определении контекста. Аналогично атрибут default-destroy-method определяет общий метод             ====-->
    <!--==== уничтожения для всех компонентов в определении контекста. В данном случае фреймворку Spring         ====-->
    <!--==== предписывается инициализировать все компоненты, описанные в файле определения контекста, вызовом    ====-->
    <!--==== метода turnOnLights() и уничтожать их вызовом метода turnOffLights() (если эти методы существуют    ====-->
    <!--==== иначе ничего не произойдет).                                                                        ====-->

    <!--=============================================================================================================-->
    <!--====================================== Внедрение в свойства компонентов =====================================-->
    <!--=============================================================================================================-->
    <bean id="kenny0" class="springidol.Instrumentalist"/>


    <!--=============================================================================================================-->
    <!--========================================= Внедрение простых значений ========================================-->
    <!--=============================================================================================================-->
    <!--==== Элемент <property> в этом фрагменте XML предписывает фреймворку Spring вызвать метод setSong()      ====-->
    <!--==== для записи значения "Jingle Bells" в свойство song                                                  ====-->
    <!--====                                                                                                     ====-->
    <!--==== Но элемент <property> позволяет внедрять не только строковые значения. В атрибуте value можно также ====-->
    <!--==== указывать числовые ( int , float , java.lang.Double и другие) и логические значения. Например,      ====-->
    <!--==== представим, что класс Instrumentalist имеет свойство age типа int , определяющее возраст музыканта. ====-->
    <!--==== Тогда можно было бы указать возраст Кенни, как показано ниже:                                       ====-->
    <!--==== <bean id="kenny"                                                                                    ====-->
    <!--====         class="com.springinaction.springidol.Instrumentalist">                                      ====-->
    <!--====     <property name="song" value="Jingle Bells" />                                                   ====-->
    <!--====     <property name="age" value="37" />                                                              ====-->
    <!--==== </bean>                                                                                             ====-->
    <!--====                                                                                                     ====-->
    <!--==== Обратите внимание, что при определении числового значения атрибут value используется точно так же,  ====-->
    <!--==== как при определении строкового значения. Фреймворк Spring автоматически определяет тип значения,    ====-->
    <!--==== опираясь на тип свойства. Поскольку свойство age имеет тип int , Spring знает, что строку "37"      ====-->
    <!--==== следует преобразовать в целочисленное значение перед вызовом метода setAge().                       ====-->

    <!--<start id="kenny_bean" />-->
    <bean id="kenny1" class="springidol.Instrumentalist">
        <property name="song" value="Jingle Bells"/>
    </bean>
    <!--<end id="kenny_bean" />-->


    <!--=============================================================================================================-->
    <!--===================================== Внедрение ссылок на другие компоненты =================================-->
    <!--=============================================================================================================-->

    <!--<start id="saxophone_bean" />-->
    <bean id="saxophone" class="springidol.Saxophone"/>
    <!--<end id="saxophone_bean" />-->

    <!--<start id="kenny2_bean" />-->
    <bean id="kennySaxophone" class="springidol.Instrumentalist">
        <property name="song" value="Jingle Bells"/>
        <property name="instrument" ref="saxophone"/>
    </bean>
    <!--<end id="kenny2_bean" />-->

    <!--==== Класс Piano можно объявить компонентом Spring, как показано ниже:                                   ====-->
    <bean id="piano" class="springidol.Piano"/>

    <!--==== Теперь, после объявления компонента piano , чтобы поменять инструмент, Кенни достаточно просто      ====-->
    <!--==== изменить объявление компонента kenny , как показано ниже:                                           ====-->

    <bean id="kennyPiano" class="springidol.Instrumentalist">
        <property name="song" value="Jingle Bells"/>
        <property name="instrument" ref="piano"/>
    </bean>


    <!--=============================================================================================================-->
    <!--====================================== Внедрение внутренних компонентов =====================================-->
    <!--=============================================================================================================-->
    <!--==== Проблема, однако, состоит в том, что Кенни немного обеспокоен гигиеническими последствиями от       ====-->
    <!--==== совместного использования своего саксофона с другими музыкантами. Он скорее предпочел бы иметь      ====-->
    <!--==== свой личный саксофон. Чтобы помочь Кенни избежать заражения чужими микробами, мы воспользуемся      ====-->
    <!--==== технологией Spring, известной как внутренние компоненты.                                            ====-->
    <!--====                                                                                                     ====-->
    <!--==== Как Java-разработчик вы, вероятно, хорошо знакомы с понятием внутренних классов – классов, которые  ====-->
    <!--==== определены в пределах других классов. Аналогично и внутренние компоненты – это компоненты, которые  ====-->
    <!--==== определяются внутри других компонентов. Для иллюстрации рассмотрим новую конфигурацию компонента    ====-->
    <!--==== kenny, где его саксофон объявляется как внутренний компонент:                                       ====-->

    <bean id="kennySaxophonePrivate" class="springidol.Instrumentalist">
        <property name="song" value="Jingle Bells"/>
        <property name="instrument">
            <bean class="springidol.Saxophone"/>
        </property>
    </bean>

    <!--==== Внутренние компоненты можно внедрять не только с помощью приема внедрения через методы записи.      ====-->
    <!--==== Внутренние компоненты можно также внедрять через аргументы конструктора, как показано в следующем   ====-->
    <!--==== новом объявлении компонента duke:                                                                   ====-->

    <bean id="dukeSonnete29Private"
          class="springidol.PoeticJuggler">
        <constructor-arg value="15"/>
        <constructor-arg>
            <bean class="springidol.Sonnet29"/>
        </constructor-arg>
    </bean>

    <!--==== Обратите внимание, что внутренние компоненты не имеют атрибута id. Нет ничего противозаконного в    ====-->
    <!--==== том,чтобы добавить атрибут id в объявление внутреннего компонента, однако в этом нет необходимости, ====-->
    <!--==== потому что к внутреннему компоненту никто и никогда не будет обращаться по имени. Это является      ====-->
    <!--==== основным недостатком внутренних компонентов: они не могут быть повторно использованы. Внутренние    ====-->
    <!--==== компоненты могут использоваться только для однократного внедрения, и к ним не могут обращаться      ====-->
    <!--==== другие компоненты.                                                                                  ====-->
    <!--==== Можно также заметить, что определение внутреннего компонента оказывает негативное влияние на        ====-->
    <!--==== удобочитаемость конфигурационных XML-файлов.                                                        ====-->


    <!--=============================================================================================================-->
    <!--=============================== Связывание свойств с помощью пространства имен "p" ==========================-->
    <!--=============================================================================================================-->
    <!--==== Внедрение значений и ссылок в свойства компонентов с помощью элемента <property> не представляет    ====-->
    <!--==== большого труда. Тем не менее пространство имен p фреймворка Spring позволяет использовать иной      ====-->
    <!--==== способ связывания свойства компонентов, не требующий такого большого количества угловых скобок.     ====-->
    <!--==== Пространство имен p имеет URI схемы http://www.springframework.org/schema/p. Для его использования  ====-->
    <!--==== достаточно просто добавить его определение в XML-файл конфигурации Spring:                          ====-->
    <!--====                                                                                                     ====-->
    <!--====  <?xml version="1.0" encoding="UTF-8"?>                                                             ====-->
    <!--====  <beans xmlns="http://www.springframework.org/schema/beans"                                         ====-->
    <!--====      xmlns:p="http://www.springframework.org/schema/p"                                              ====-->
    <!--====      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"                                          ====-->
    <!--====      xsi:schemaLocation="http://www.springframework.org/schema/beans                                ====-->
    <!--====          http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">                         ====-->
    <!--====                                                                                                     ====-->
    <!--==== После этого появится возможность использовать для связывания свойств атрибуты с префиксом p:        ====-->
    <!--==== элемента <bean> . Например, взгляните на следующее объявление компонента kenny :                    ====-->

    <bean id="kennyP" class="springidol.Instrumentalist"
          p:song="Jingle Bells"
          p:instrument-ref="saxophone"/>

    <!--==== Атрибут p:song со значением "Jingle Bells" внедряет это значение в свойство song . Однако атрибут   ====-->
    <!--==== p:instrument-ref со значением "saxophone" в действительности внедряет в свойство instrument ссылку  ====-->
    <!--==== на компонент с идентификатором saxophone . Окончание -ref подсказывает фреймворку Spring, что       ====-->
    <!--==== вместо буквального значения он должен внедрить ссылку на соответствующий компонент. Выбор между     ====-->
    <!--==== элементом  <property> и пространством имен p остается за вами. Они действуют совершенно одинаково.  ====-->
    <!--==== Основное преимущество пространства имен p состоит в том, что оно обеспечивает более краткую форму   ====-->
    <!--==== записи.                                                                                             ====-->


    <!--=============================================================================================================-->
    <!--========================================= Внедрение коллекций ===============================================-->
    <!--=============================================================================================================-->
    <!--==== А возможно ли с помощью Spring инициализировать свойства, имеющие множество значений, что, если     ====-->
    <!--==== свойство является коллекцией значений? Фреймворк Spring предлагает четыре типа элементов определе-  ====-->
    <!--==== ния коллекций, которые пригодятся для конфигурирования значений, являющихся коллекциями.            ====-->
    <!--==== Элементы <list> и <set> можно использовать для настройки свойств, которые являются массивами или    ====-->
    <!--==== одной из реализаций java.util.Collection . Как будет показано чуть ниже, фактическая реализация     ====-->
    <!--==== коллекции, используемая для определения свойства,                                                   ====-->
    <!--====                                                                                                     ====-->
    <!--====  <list>   Связывание списка значений, допускаются повторяющиеся значения                            ====-->
    <!--====   <set>   Связывание множества значений, гарантирует отсутствие повторяющихся значений              ====-->
    <!--====   <map>   Связывание коллекций пар имя/значение, где имя и значение могут быть значениями           ====-->
    <!--====           любых типов                                                                               ====-->
    <!--==== <props>   Связывание коллекций пар имя/значение,где имя и значение должны имеет строковый           ====-->
    <!--====           тип (String)                                                                              ====-->
    <!--====                                                                                                     ====-->
    <!--==== Что касается элементов <map> и <props> , они соответствуют коллекциям с интерфейсами java.util.Map  ====-->
    <!--==== и java.util.Properties соответственно. Эти типы коллекций можно использовать, когда требуется       ====-->
    <!--==== коллекция, состоящая из пар ключ/значение. Ключевым отличием между ними состоит в том, что при      ====-->
    <!--==== использовании элемента <props> ключи и значения в коллекции должны быть значениями типа String,     ====-->
    <!--==== тогда как при использовании элемента <map> ключи и значения могут быть любых типов.                 ====-->


    <!--=============================================================================================================-->
    <!--============================== Внедрение списков, множеств и массивов =======================================-->
    <!--=============================================================================================================-->
    <!--==== Чтобы передать Хэнку коллекцию инструментов для выступления, воспользуемся элементом <list> :       ====-->

    <bean id="hankList"
          class="springidol.OneManBand">
        <property name="instruments">
            <list>
                <ref bean="guitar"/>
                <ref bean="cymbal"/>
                <ref bean="harmonica"/>
                <ref bean="guitar"/>
            </list>
        </property>
    </bean>
    <bean id="guitar" class="springidol.Guitar"/>
    <bean id="cymbal" class="springidol.Cymbal"/>
    <bean id="harmonica" class="springidol.Harmonica"/>

    <!--==== Элемент <list> содержит одно или более значений. Здесь элементы <ref> используются для определения  ====-->
    <!--==== ссылок на другие компоненты в контексте Spring и передают Хэнку гитару, цимбалы и губную гармошку.  ====-->
    <!--==== Однако внутри элемента <list> можно также использовать другие элементы, определяющие значения,      ====-->
    <!--==== включая <value> , <bean> и <null/> . В действительности элемент <list> может содержать в себе       ====-->
    <!--==== другие элементы <list> как элементы многомерных списков. В листинге 2.8 свойство instruments класса ====-->
    <!--==== OneManBand имеет тип java.util.Collection , и для сохранения в нем значений типа Instrument         ====-->
    <!--==== используются обобщения Java 5. Но элемент <list> может применяться к свойствам, которые могут быть  ====-->
    <!--==== любыми реализациями java.util.Collection или массивом. Другими словами, элемент <list> можно было   ====-->
    <!--==== бы использовать, даже если свойство instruments было бы объявлено как:                              ====-->
    <!--==== java.util.List<Instrument> instruments; или как:  Instrument[] instruments;                         ====-->
    <!--====                                                                                                     ====-->
    <!--==== Аналогично для связывания свойств, являющихся коллекциями или массивами можно использовать          ====-->
    <!--==== элемент <set> :                                                                                     ====-->

    <bean id="hankSet"
          class="springidol.OneManBand">
        <property name="instruments">
            <set>
                <ref bean="guitar"/>
                <ref bean="cymbal"/>
                <ref bean="harmonica"/>
                <ref bean="harmonica"/>
            </set>
        </property>
    </bean>

    <!--==== Как уже говорилось, элементы <list> и <set> могут использоваться для связывания значений с любой    ====-->
    <!--==== реализацией java.util.Collection или массивом. Если свойство имеет тип java.util.Set , это еще не   ====-->
    <!--==== означает, что для его инициализации следует обязательно использовать элемент <set> . Даже при том,  ====-->
    <!--==== что возможность инициализировать свойство типа java.util.List с помощью элемента <set> может        ====-->
    <!--==== показаться странной, в действительности это вполне допустимо.В этом случае гарантируется            ====-->
    <!--==== уникальность элементов списка List.                                                                 ====-->


    <!--=============================================================================================================-->
    <!--======================================= Связывание отображений ==============================================-->
    <!--=============================================================================================================-->

    <bean id="hankMap" class="springidol2.OneManBand">
        <property name="instruments">
            <map>
                <entry key="GUITAR" value-ref="guitar"/>
                <entry key="CYMBAL" value-ref="cymbal"/>
                <entry key="HARMONICA" value-ref="harmonica"/>
            </map>
        </property>
    </bean>

    <!--==== Элемент <map> объявляет значение типа java.util.Map . Каждый элемент <entry> определяет один элемент====-->
    <!--==== отображения. В предыдущем примере атрибут key определяет ключ элемента отображения, а атрибут       ====-->
    <!--==== value-ref – значение элемента отображения как ссылку на другой компонент внутри контекста Spring.   ====-->
    <!--==== Элемент <map> – это единственный способ внедрения пар ключ/значение в свойства компонента, когда    ====-->
    <!--==== один из объектов не является строкой. Посмотрим, как использовать элемент <props> для настройки     ====-->
    <!--==== отображения строка в строку.                                                                        ====-->
    <!--====                                                                                                     ====-->
    <!--==== key: Определяет ключ элемента отображения как строку                                                ====-->
    <!--==== key-ref: Определяет ключ элемента отображения как ссылку на компонент в контексте Spring            ====-->
    <!--==== value: Определяет значение элемента отображения как строку                                          ====-->
    <!--==== value-ref Определяет значение элемента отображения как ссылку на компонент в контексте Spring       ====-->
    <!--====                                                                                                     ====-->
    <!--==== Но если при формировании отображения обнаружится, что ключи и значения в нем являются строками,     ====-->
    <!--==== возможно, предпочтительнее будет вместо класса Map использовать интерфейс java.util.Properties.     ====-->
    <!--==== Интерфейс Properties служит примерно той же цели, что и класс Map, но ограничивает ключи и значения ====-->
    <!--==== строковым типом. Для иллюстрации представьте, что вместо коллекции строк и ссылок на компоненты в   ====-->
    <!--==== свойство объекта OneManBand внедряется отображение строки в строку Java.util.Properties . Новое     ====-->
    <!--==== свойство instruments в этом случае можно было бы изменить, как показано ниже.                       ====-->
    <!--==== Чтобы связать звуки, издаваемые инструментами, со свойством instruments , в этом случае можно       ====-->
    <!--==== использовать элемент <props>, как показано в следующем объявлении компонента hank :                 ====-->

    <bean id="hankProperty" class="springidol2.OneManBand2">
        <property name="instruments">
            <props>
                <prop key="GUITAR">STRUM STRUM STRUM</prop>
                <prop key="CYMBAL">CRASH CRASH CRASH</prop>
                <prop key="HARMONICA">HUM HUM HUM</prop>
            </props>
        </property>
    </bean>

    <!--==== Элемент <props> создает отображение типа java.util.Properties, каждый член которого определяется    ====-->
    <!--==== элементом <prop> . Каждый элемент <prop> имеет атрибут key , определяющий ключ члена отображения    ====-->
    <!--==== Properties , а значение определяется содержимым элемента<prop>.                                     ====-->
    <!--==== Это, пожалуй, самый сложный для обсуждения элемент конфигурации Spring, потому что термин «property»====-->
    <!--==== сильно перегружен. Здесь важно придерживаться следующих правил:                                     ====-->
    <!--====    <property> – это элемент для внедрения значения или ссылкина компонент в «обычное»               ====-->
    <!--====    свойство компонента;                                                                             ====-->
    <!--====    <props> – это элемент для определения коллекций типа java.util.Properties;                       ====-->
    <!--====    <prop> – это элемент для определения члена коллекции <props> .                                   ====-->


    <!--=============================================================================================================-->
    <!--===================================== Внедрение пустого значения ============================================-->
    <!--=============================================================================================================-->
    <!--==== Помимо всего прочего, фреймворк Spring может также внедрять в свойства компонентов или аргументы    ====-->
    <!--==== конструкторов пустые значения. Или, если говорить точнее, значение null. Чаще всего дела обстоят    ====-->
    <!--==== именно так – свойства отправляются в путь пустыми и будут оставаться таковыми, пока им не будут     ====-->
    <!--==== присвоены другие значения. Однако некоторые компоненты могут сами присваивать свойствам непустые    ====-->
    <!--==== значения по умолчанию. Что, если по каким-то причинам необходимо, чтобы это свойство получило       ====-->
    <!--==== пустое значение? В этом случае недостаточно просто предполагать, что свойство будет иметь пустое    ====-->
    <!--==== значение, – необходимо явно присвоить ему значение null. Чтобы присвоить свойству значение null,    ====-->
    <!--==== достаточно просто воспользоваться элементом <null/> . Например:                                     ====-->

    <bean id="hankNullProperty"
          class="springidol.Instrumentalist">
        <property name="song" value="Jingle Bells"/>
        <property name="instrument">
            <null/>
        </property>
    </bean>

    <!--==== Другая причина для явного внедрения значения null в свойство отменить автоматическое связывание     ====-->
    <!--==== значения свойства.                                                                                  ====-->


    <!--=============================================================================================================-->
    <!--====================== Внедрение выражений (Spring Expression Language, SpEL) ===============================-->
    <!--=============================================================================================================-->
    <!--==== В версии Spring 3.0 появилась возможность использовать язык выражений Spring (Spring Expression     ====-->
    <!--==== Language, SpEL) – мощный, но краткий способ внедрения значений в свойства компонентов или аргументы ====-->
    <!--==== конструкторов с помощью выражений, которые вычисляются на этапе выполнения. С помощью SpEL можно    ====-->
    <!--==== творить чудеса, обрабатывая такие ситуации, которые было бы очень сложно (или даже невозможно)      ====-->
    <!--==== обработать с применением традиционных приемов связывания.                                           ====-->
    <!--==== Язык SpEL обеспечивает массу интересных возможностей, среди которых:                                ====-->
    <!--====         получение ссылок на компоненты по их идентификаторам;                                      ====-->
    <!--====         вызов методов и обращение к свойствам объектов;                                            ====-->
    <!--====         математические и логические операции над значениями, а так же операции отношения;          ====-->
    <!--====         сопоставление с регулярными выражениями;                                                   ====-->
    <!--====         операции с коллекциями.                                                                    ====-->
    <!--==== Создание выражений на языке SpEL связано с использованием разнообразных синтаксических конструкций. ====-->
    <!--==== Даже наиболее замысловатые выражения на языке SpEL зачастую состоят из более простых подвыражений.  ====-->
    <!--====                                                                                                     ====-->
    <!--==== Конечная цель выражений на языке SpEL состоит в том, чтобы обеспечить возможность вычисления        ====-->
    <!--==== некоторых значений. В процессе вычислений могут участвовать другие значения. Самой простой          ====-->
    <!--==== разновидностью значений в языке SpEL являются литералы, ссылки на свойства компонентов и константы  ====-->
    <!--==== в некоторых классах.                                                                                ====-->
    <!--==== Простейшим выражением на языке SpEL является выражение, состоящее из одного литерального значения.  ====-->
    <!--==== Неудивительно, что результатом этого выражения является целое число 5. Это значение можно было бы   ====-->
    <!--==== внедрить в свойство компонента с помощью конструкции #{} в атрибуте value элемента <property> , как ====-->
    <!--==== показано ниже:                                                                                      ====-->
    <!--====                        <property name="count" value="#{5}"/>                                        ====-->
    <!--==== Конструкция #{} подсказывает фреймворку Spring, что ее содержимое является выражением на языке SpEL.====-->
    <!--==== Эти выражения можно также смешивать с обычными значениями:                                          ====-->
    <!--====                        <property name="message" value="The value is #{5}"/>                         ====-->
    <!--==== На языке SpEL можно также определять вещественные числа. Например:                                  ====-->
    <!--====                        <property name="frequency" value="#{89.7}"/>                                 ====-->
    <!--==== Числа могут записываться в научной форме записи. Как показано в следующем фрагменте, который        ====-->
    <!--==== присваивает значение 10000.0 свойству capacity :                                                    ====-->
    <!--====                        <property name="capacity" value="#{1e4}"/>                                   ====-->
    <!--==== Язык SpEL также поддерживает строковые литералы, которые могут заключаться в апострофы или кавычки. ====-->
    <!--==== Например, внедрение строкового литерала в свойство компонента можно записать так:                   ====-->
    <!--====                        <property name="name" value="#{'Chuck'}"/>                                   ====-->
    <!--==== Если для определения значений XML-атрибутов используются апострофы, выражение на языке SpEL можно   ====-->
    <!--==== заключить в кавычки:                                                                                ====-->
    <!--====                        <property name='name' value='#{"Chuck"}'/>                                   ====-->
    <!--==== Для определения логических значений можно использовать пару литералов true и false . Например,      ====-->
    <!--==== значение false можно выразить так:                                                                  ====-->
    <!--====                        <property name="enabled" value="#{false}"/>                                  ====-->
    <!--====                                                                                                     ====-->
    <!--==== Я считаю, что нет смысла использовать выражения на языке SpEL,содержащие только литералы. Но напомню====-->
    <!--==== что даже самые замысловатые выражения состоят из более простых подвыражений. Поэтому знание приемов ====-->
    <!--==== работы с литералами не будет лишним.                                                                ====-->
    <!--====                                                                                                     ====-->
    <!--====                        <property name="instrument" value="#{saxophone}"/>                           ====-->
    <!--====                        <property name="instrument" ref="saxophone"/>                                ====-->
    <!--==== Да, результат будет тем же самым. И да, для этого не нужно использовать выражение на языке SpEL.    ====-->
    <!--==== Но весь интерес в том, что это возможно, и чуть ниже я покажу, в каких ситуациях может при-         ====-->
    <!--==== годиться возможность внедрения ссылок на компоненты с помощью выражений                             ====-->
    <!--====                                                                                                     ====-->
    <!--==== При конфигурировании компонента carl можно воспользоваться выражением на языке SpEL, чтобы          ====-->
    <!--==== скопировать произведение из свойства song Кенни, как показано ниже:                                 ====-->

    <!--<start id="carl_bean"/>-->
    <bean id="carl" class="springidol.Instrumentalist">
        <property name="song" value="#{kenny1.song}"/>
    </bean>
    <!--<end id="carl_bean"/>-->

    <!--==== Возможность обращения к свойствам – не единственное, что можно делать с компонентами. Точно так же  ====-->
    <!--==== можно вызывать методы компонентов. Например, представьте, что имеется компонент songSelector с      ====-->
    <!--==== методом selectSong() , возвращающим музыкальное произведение для исполнения. В этом случае Карл мог ====-->
    <!--==== бы исполнять произведения, предлагаемые компонентом songSelector :                                  ====-->
    <!--====            <property name="song" value="#{songSelector.selectSong()}"/>                             ====-->

    <bean id="songSelector" class="springidol2.SongSelector"/>

    <bean id="carlSongSelector1" class="springidol.Instrumentalist">
        <property name="song" value="#{songSelector.selectSong()}"/>
        <property name="instrument" ref="piano"/>
    </bean>

    <bean id="carlSongSelector2" class="springidol.Instrumentalist">
        <property name="song" value="#{songSelector.selectSong().toUpperCase()}"/>
        <property name="instrument" ref="piano"/>
    </bean>

    <!--==== Этот трюк будет срабатывать всегда... пока метод selectSong() не вернет значение null . Если в      ====-->
    <!--==== какой-то момент selectSong() вернет null , во время вычисления выражения возникнет исключение       ====-->
    <!--==== NullPointerException. Чтобы избежать появления жуткого исключения NullPointer-Exception в выражении,====-->
    <!--==== следует задействовать защищенный оператор доступа к свойству:                                       ====-->
    <!--====           <property name="song" value="#{songSelector.selectSong()?.toUpperCase()}"/>               ====-->

    <bean id="carlSongSelectorSaveNull" class="springidol.Instrumentalist">
        <property name="song" value="#{songSelector.selectSongReturnNull()?.toUpperCase()}"/>
        <property name="instrument" ref="piano"/>
    </bean>

    <!--==== Здесь вместо одиночной точки (.) для вызова метода toUpperCase() используется оператор ?. . Этот    ====-->
    <!--==== оператор сначала проверяет, не является ли пустым элемент слева, и только потом выполняет обра-     ====-->
    <!--==== щение к элементу справа. То есть если selectSong() вернет значение null , тогда выражение не будет  ====-->
    <!--==== даже пытаться вызвать toUpperCase().                                                                ====-->
    <!--====                                                                                                     ====-->
    <!--==== Ключом к использованию методов класса и констант в языке SpEL является оператор T() . Например,     ====-->
    <!--==== чтобы обратиться к Java классу Math в выражении на языке SpEL, необходимо использовать оператор     ====-->
    <!--==== T() , как показано ниже:                                                                            ====-->
    <!--====            T(java.lang.Math)                                                                        ====-->
    <!--==== Результатом оператора T() , представленного здесь, является объект типа Class , представляющий класс====-->
    <!--==== java.lang.Math . Этот результат можно было бы даже внедрить в свойство компонента типа Class . Но   ====-->
    <!--==== истинная ценность значения, возвращаемого оператором T() , заключается в возможности доступа к      ====-->
    <!--==== статическим методам и константам указанного класса.                                                 ====-->
    <!--==== Например, предположим, что в свойство компонента необходимо внедрить значение pi . В этом случае    ====-->
    <!--==== достаточно просто обратиться к константе PI в классе Math , как показано ниже:                      ====-->

    <bean id="numberPI" class="springidol2.ExNumber">
        <property name="value" value="#{T(java.lang.Math).PI}"/>
    </bean>

    <!--==== Аналогично с помощью оператора T() можно вызывать статические методы. Например, ниже показано, как  ====-->
    <!--==== в свойство компонента внедрить случайное число (в диапазоне от 0 до 1):                             ====-->

    <bean id="randomNumber" class="springidol2.ExNumber">
        <property name="value" value="#{T(java.lang.Math).random()}"/>
    </bean>

    <!--==== Язык SpEL включает несколько операторов для манипулирования значениями в выражениях                 ====-->
    <!--====                Арифметические:   +, -, *, /, %, ^                                                   ====-->
    <!--====                Операторы отношений:   <, >, ==, <=, >=, lt, gt, eq, le, ge                          ====-->
    <!--====                Логические:  and, or, not, !                                                         ====-->
    <!--====                Условные:   ?: (трехместный), ?: (Элвис)                                             ====-->
    <!--====                Регулярные выражения:   matches                                                      ====-->

    <!--=== Выполнение математических операций в языке SpEL ===-->
    <bean id="exNumber" class="springidol2.ExNumber"/>

    <bean id="numerAdd" class="springidol2.ExNumber">
        <!--<property name="value" value="#{numerAdd.TOTAL + 42}"/>-->
        <property name="value" value="#{exNumber.TOTAL + 42}"/>
    </bean>

    <!--==== Другие арифметические операторы языка SpEL действуют точно так же, как в языке Java. ====-->

    <bean id="numerSubtracting" class="springidol2.ExNumber">
        <property name="value" value="#{exNumber.TOTAL - 20}"/>
    </bean>

    <bean id="numerMultiplication" class="springidol2.ExNumber">
        <property name="value" value="#{2 * T(java.lang.Math).PI * exNumber.TOTAL}"/>
    </bean>

    <bean id="numerDividing" class="springidol2.ExNumber">
        <property name="value" value="#{exNumber.TOTAL / 3}"/>
    </bean>

    <bean id="numerModule" class="springidol2.ExNumber">
        <property name="value" value="#{exNumber.TOTAL % 3}"/>
    </bean>

    <!--==== В отличие от Java, язык SpEL также предлагает оператор возведения в степень:                        ====-->
    <bean id="numerStepen" class="springidol2.ExNumber">
        <property name="value" value="#{T(java.lang.Math).PI * exNumber.TOTAL ^ 2}"/>
    </bean>

    <!--==== Даже при том, что речь идет об арифметических операторах языка SpEL, стоит упомянуть, что оператор
             + перегружен и способен выполнять конкатенацию строковых значений. Например:                        ====-->
    <bean id="concatenation0" class="springidol2.PerformerB">
        <property name="firstName" value="FN"/>
        <property name="lastName" value="LN"/>
    </bean>
    <bean id="concatenation" class="springidol2.PerformerB">
        <property name="firstName" value="FN"/>
        <property name="lastName" value="LN"/>
        <!-- Ostorozno s etim opredileniem return null null-->
        <!--<property name="fullName" value="#{concatenation.firstName + ' ' + concatenation.lastName}"/>-->
        <property name="fullName" value="#{concatenation0.firstName + ' ' + concatenation0.lastName}"/>
    </bean>

    <!--==== Например, чтобы выяснить равенство двух чисел, можно воспользоваться оператором равенства ( == ): ====-->
    <bean id="chekBool" class="springidol2.ExNumber">
        <!--<property name="bool" value="#{exNumber.NUMBER_100 eq 100}"/>-->
        <property name="bool" value="#{exNumber.NUMBER_100 == 100}"/>
    </bean>

    <!--==== Аналогично для сравнения разных значений можно использовать операторы «меньше чем» (<) и «больше
             чем» (>). Кроме того, язык SpEL поддерживает операторы «больше или равно» (>=) и «меньше
             или равно» ( <= ).

             К сожалению, операторы «меньше чем» и «больше чем» могут вызывать проблемы при использовании в
             конфигурационных XML-файлах, так как в языке разметки XML они имеют специальное значение. Поэтому при
             использовании выражений на языке SpELв XML-файлах 1 лучше использовать текстовые эквиваленты этих
             операторов.

             Язык SpEL включает несколько текстовых операторов для сравнения значений в выражениях
                              Равно:     ==      eq
                         Меньше чем:     <       lt
                   Меньше или равно:     <=      le
                         Больше чем:     >       gt
                   Больше или равно:     >=      ge

              Язык SpEL включает несколько операторов для манипулирования логическими значениями в выражениях
                         and    Логическая операция И; чтобы результатом выражения было значение true, оба
                                операнда должны иметь значение true
                          or    Логическая операция ИЛИ; чтобы результатом выражения было значение true, хотя бы
                                один из операндов должен иметь значение true
                   not или !    Логическая операция НЕ; инвертирует значение целевого выражения                  ====-->

    <bean id="chekL" class="springidol2.ExNumber">
        <!--<property name="bool" value="#{exNumber.str == 'circle' and exNumber.NUMBER_100 gt 10000}"/>-->
        <property name="bool" value="#{exNumber.str == 'AAA' and exNumber.NUMBER_100 gt 10}"/>
    </bean>

    <bean id="checkInvert" class="springidol2.ExNumber">
        <property name="bool" value="#{! false }"/>
        <!--<property name="bool" value="#{not false }"/>-->
    </bean>

    <!--==== Условные вычисления ====-->
    <!--==== В этом случае можно использовать трехместный (тернарный) оператор ( ?: )
             Трехместный оператор в языке SpEL действует точно так же, как в языке Java. В данном случае, если
             будет выбрана песня «Jingle Bells», в свойство instrument будет внедрена ссылка на компонент piano.
             В противном случае в него будет внедрена ссылка на компонент с идентификатором saxophone. ====-->

    <bean id="instrumentalist2" class="springidol.Instrumentalist">
        <property name="song" value="Jingle Bells"/>
        <property name="instrument" value="#{kenny1.song=='Jingle Bells'?piano:saxophone}"/>
    </bean>

    <!--==== Типичная область применения трехместного оператора – проверка значения на равенство null и внедрение
             значения по умолчанию, если равенство соблюдается.                                                  ====-->
    <bean id="instrumentalist3" class="springidol.Instrumentalist">
        <!--<property name="song" value="#{kenny1.song != null ? kenny1.song : 'Greensleeves'}"/>-->
        <property name="song" value="#{ songSelector.selectSongReturnNull() != null ? kenny1.song : 'Greensleeves'}"/>
        <property name="instrument" ref="piano"/>
    </bean>

    <!--==== Это выражение построено правильно, но в нем имеется повторяющийся элемент – ссылка на свойство
             kenny.song . Язык SpEL предлагает разновидность трехместного оператора, упрощающую подобные
             выражения:                                                                                          ====-->
    <bean id="instrumentalist4" class="springidol.Instrumentalist">
        <property name="song" value="#{ kenny1.song ?: 'Greensleeves'}"/>
        <property name="instrument" ref="piano"/>
    </bean>

    <!--==== Как и в предыдущем примере, выражение вернет значение свойства kenny.song или «Greensleeves», если
             свойство kenny.song равно null . При таком способе использования оператор ?: называют оператором
             Элвиса. Этим странным названием оператор обязан сравнению со смайликами – если повернуть его на 90
             градусов, вопросительный знак будет напоминать прическу знаменитого Элвиса Пресли                   ====-->

    <!--==== При работе с текстом иногда бывает желательно проверить его совпадение с некоторым шаблоном. Язык
             SpEL поддерживает сопоставление с шаблонами с помощью оператора matches. Оператор matches пытается
             применить регулярное выражение(в аргументе справа) к строковому значению (в аргументе слева).
             Результатом выполнения оператора matches является логическое значение: true – если строка совпадает
             с шаблоном и false – в противном случае. ====-->
    <bean id="valueEmail" class="springidol2.ExNumber">
        <property name="bool" value="#{ exNumber.EMAIL matches
                    '^[_A-Za-z0-9-+](.[_A-Za-z0-9-]+)*@[A-Za-z0-9-]+(.[A-Za-z0-9]+)*(.[A-Za-z]{2,})$'}"/>
        <!--<property name="bool" value="#{ exNumber.EMAIL_FALSE matches-->
        <!--'^[_A-Za-z0-9-+](.[_A-Za-z0-9-]+)*@[A-Za-z0-9-]+(.[A-Za-z0-9]+)*(.[A-Za-z]{2,})$'}"/>-->
    </bean>

    <!--==== Обработка коллекций на языке SpEL Одни из самых необычных особенностей языка SpEL связаны с
             обработкой коллекций. Сослаться на отдельный элемент коллекции в языке SpEL можно точно так же,
             как в языке Java. Но в SpEL имеется мощный механизм выборки элементов коллекций на основе значений
             их свойств. Он также позволяет извлекать значения свойств элементов коллекций и составлять из них
             новые коллекции.
             Для примера предположим, что имеется некоторый класс City, представленный ниже (для экономии места
             из объявления были исключены методы доступа):                                                       ====-->
    <util:list id="cities">
        <bean class="springidol2.City"
              p:name="Chicago" p:state="IL" p:population="2853114"/>
        <bean class="springidol2.City"
              p:name="Atlanta" p:state="GA" p:population="537958"/>
        <bean class="springidol2.City"
              p:name="Dallas" p:state="TX" p:population="1279910"/>
        <bean class="springidol2.City"
              p:name="Houston" p:state="TX" p:population="2242193"/>
        <bean class="springidol2.City"
              p:name="Odessa" p:state="TX" p:population="90943"/>
        <bean class="springidol2.City"
              p:name="El Paso" p:state="TX" p:population="613190"/>
        <bean class="springidol2.City"
              p:name="Jal" p:state="NM" p:population="1996"/>
        <bean class="springidol2.City"
              p:name="Las Cruces" p:state="NM" p:population="91865"/>
    </util:list>

    <!--==== Элемент <util:list> определен в пространстве имен util фреймворка Spring. Фактически он создает
             компонент типа java.util.List, содержащий все значения или компоненты, перечисленные в нем. В
             данном случае это список из восьми компонентов City. Язык SpEL имеет несколько удобных операторов
             для работы с коллекциями, подобными этой.                                                           ====-->

    <bean id="chosenCity" class="springidol2.ChosenCity">
        <property name="city" value="#{cities[2]}"/>
    </bean>

    <bean id="chosenCity1" class="springidol2.ChosenCity">
        <property name="city" value="#{cities[T(java.lang.Math).random() * cities.size()]}"/>
        <!--<property name="city" value="#{cities[2]}"/>-->
    </bean>

    <!--==== В любом случае для доступа к элементу коллекции по его индексу должны использоваться квадратные
             скобки ([]). Оператор [] также можно использовать для извлечения элементов из отображений
             java.util.Map . Например, представим, что объекты City находятся в отображении ( Map ), где роль
             ключей играют названия городов. В этом случае элемент с городом Dallas (Даллас) можно извлечь так:
                        <property name="chosenCity" value="#{cities['Dallas']}"/>

            Стоит также отметить, хотя это и не имеет прямого отношения к работе с коллекциями, что оператор []
            можно применять к строковым значениям для извлечения одиночных символов. Например, следующее выражение
            вернет "s" : 'This is a test'[3]====-->



    <!--=============================================================================================================-->
    <!--==== ??????????????????????????????????????????????????????????????????????????????????????????????????? ====-->
    <!--=============================================================================================================-->
    <bean id="systemProperties" class="java.util.Properties">

    </bean>
    <!--<start id="stan_bean"/>-->
    <bean id="stan" class="springidol.Instrumentalist">
        <!--<property name="song" value="#{systemProperties.STANS_SONG}"/>-->
        <property name="song" value="Monkey song"/>
    </bean>
    <!--<end id="stan_bean"/>-->

    <!--<start id="song_list_bean" />-->
    <util:list id="songList">
        <bean class="springidol.Song">
            <constructor-arg value="That Old Black Magic"/>
            <constructor-arg value="Arlen and Mercer"/>
            <constructor-arg value="That old black magic has me in its spell..."/>
        </bean>
        <bean class="springidol.Song">
            <constructor-arg value="Every Little Thing She Does is Magic"/>
            <constructor-arg value="Sting"/>
            <constructor-arg value="Though Ive tried before to tell her..."/>
        </bean>
        <bean class="springidol.Song">
            <constructor-arg value="Magic Carpet Ride"/>
            <constructor-arg value="Moreve and Kay"/>
            <constructor-arg value="I like to dream yes, yes, right between my sound machine..."/>
        </bean>
    </util:list>
    <!--<end id="song_list_bean" />-->

    <!--<start id="songbook_bean"/>-->
    <bean id="magicSongBook" class="springidol.SongBook">
        <constructor-arg value="#{songList.![title]}"/>
    </bean>
    <!--<end id="songbook_bean"/>-->

    <!--<start id="ricky_bean"/>-->
    <bean id="ricky" class="springidol.Instrumentalist">
        <property name="song" value="#{magicSongBook.pickASong()}"/>
    </bean>
    <!--<end id="ricky_bean"/>-->
    <!--==== ??????????????????????????????????????????????????????????????????????????????????????????????????? ====-->



    <!--=============================================================================================================-->
    <!--=============================== Дополнительные способы связывания компонентов ===============================-->
    <!--=============================================================================================================-->

    <bean id="baseSaxophonist"
          class="springidol.Instrumentalist"
          abstract="true">
        <property name="instrument" ref="saxophone"/>
        <property name="song" value="Jingle Bells"/>
    </bean>

    <bean id="kenny" parent="baseSaxophonist"/>
    <bean id="david" parent="baseSaxophonist"/>



    <!--=============================================================================================================-->
    <!--====================================== Переопределение наследуемых свойств ==================================-->
    <!--=============================================================================================================-->
    <bean id="frank" parent="baseSaxophonist">
        <property name="song" value="Mary had a little lamb"/>
    </bean>



    <!--=============================================================================================================-->
    <!--========================================== Общие абстрактные свойства =======================================-->
    <!--=============================================================================================================-->
    <bean id="basePerformer" abstract="true">
        <property name="song" value="Somewhere Over the Rainbow"/>
    </bean>

    <!--<bean id="taylor" class="com.springinaction.springidol.Vocalist" parent="basePerformer"/>-->

    <bean id="stevie"
          class="springidol.Instrumentalist"
          parent="basePerformer">
        <property name="instrument" ref="guitar"/>
    </bean>



    <!--=============================================================================================================-->
    <!--============================================= Внедрение методов =============================================-->
    <!--=============================================================================================================-->
    <!--==== Фреймворк Spring поддерживает две формы внедрения методов:
                     замещение метода – позволяет во время выполнения заместить существующий метод (абстрактный
                      или конкретный) новой реализацией;
                     внедрение метода чтения – позволяет во время выполнения заместить существующий метод
                      (абстрактный или конкретный) новой реализацией, возвращающей определенный компонент из
                      контекста Spring.                                                                          ====-->

    <bean id="magicBox" class="springidol.MagicBoxImpl" />

    <bean id="harry" class="springidol.Magician">
        <property name="magicBox" ref="magicBox" />
        <!--<property name="magicBox" ref="magicBoxTiger" />-->
        <property name="magicWords" value="Bippity boppity boo" />
    </bean>


    <!--==== Как следует из названия, этот элемент используется для замены метода новой реализацией. В данном
             случае атрибут name указывает имя замещаемого метода getContents() . А атрибут replacer ссылается
             на компонент tigerReplacer , реализующий замену.                                                    ====-->
    <bean id="magicBoxTiger" class="springidol.MagicBoxImpl">
        <replaced-method name="getContents" replacer="tigerReplacer" />
    </bean>

    <!--==== Класс TigerReplacer реализует интерфейс MethodReplacer , требующий реализации единственного метода
             reimplement() . Этот метод принимает три аргумента: объект, в котором будет производиться замещение
             метода, метод, подлежащий замещению, и массив аргументов, принимаемых методом. В нашем случае
             аргументы отсутствуют, но их можно передать при необходимости. Тело метода reimplement() фактически
             становится новой реализацией метода getContents() черного ящика. В нашем примере единственное, что
             требуется, – это вернуть строку «A ferocious tiger» (свирепый тигр).                                ====-->
    <bean id="tigerReplacer" class="springidol.TigerReplacer" />

    <bean id="harryT" class="springidol.Magician">
        <property name="magicBox" ref="magicBoxTiger" />
        <property name="magicWords" value="Bippity boppity boo" />
    </bean>

    <!--==== Та-да! Симпатичная ассистентка пропала, и вместо нее появился свирепый тигр, причем без изменения
             существующей реализации MagicBoxImpl. Фокус был успешно выполнен с помощью элемента
             <replaced-method> . Стоит отметить, что хотя MagicBoxImpl имеет конкретную реализацию метода
             getContents() , метод getContents() точно так же можно было бы объявить абстрактным. В самом деле,
             прием внедрения метода с успехом может использоваться, когда фактическая реализация замещаемого
             метода не известна до момента развертывания. К этому моменту класс с замещающей реализацией метода
              можно оформить в виде JAR-файла и поместить его в библиотеку классов (classpath) приложения.       ====-->


    <!-- =========================================================================================================== -->
    <!-- ==================================== Использование внедрения методов чтения =============================== -->
    <!-- ============================================================================================================-->

    <!--==== Для поддержки внедрения методов чтения фреймворк Spring предлагает элемент <lookup-method> . Как
             и <replaced-method> , элемент <lookup-method> замещает существующий метод новой реализацией во
             время выполнения. Но элемент <lookup-method> – это упрощенный вариант элемента <replaced-method>,
             для которого нужно определить компонент в контексте Spring, возвращающий замещающий метод. Элемент
             <lookup-method> этого не требует. При его использовании не надо писать класс, реализующий интерфейс
             MethodReplacer. Следующий фрагмент XML-кода демонстрирует использование элемента <lookup-method> для
             замещения метода getInstrument() другим методом, который вернет ссылку на компонент guitar .        ====-->

    <bean id="stevieAb" class="springidol.Instrumentalist2">
        <lookup-method name="getInstrument" bean="guitarPrototype" />
        <property name="song" value="Greensleeves" />
    </bean>

    <!--==== Как и в элементе <replaced-method> , атрибут name элемента <lookup-method> определяет замещаемый
             метод. Здесь замещается метод getInstrument() . Атрибут bean определяет компонент, возвращаемый
             методом getInstrument() . В нашем случае это компонент с идентификатором guitar.                    ====-->

    <!--==== Сам по себе прием внедрения методов чтения является всего лишь разновидностью внедрения через
             методы записи. Однако это имеет значение, только когда компонент имеет область действия prototype : ====-->

    <bean id="guitarPrototype" class="springidol.Guitar" scope="prototype" />

    <!--==== Даже если компонент имеет область видимости prototype , при использовании приема внедрения через
             метод записи компонент guitar будет внедрен в свойство только однажды. Использование приема
             внедрения методов чтения гарантирует, что каждый вызов метода getInstrument() будет возвращать
             различные гитары. Это может пригодиться, если гитарист порвет струну во время выступления и по-
             требует другой инструмент. Важно помнить, что при использовании элемента <lookup-method> для
             внедрения метода чтения совсем необязательно, чтобы замещаемый метод был методом чтения (то есть
             методом, имя которого начинается со слова get ). С помощью элемента <lookup-method> можно заместить
             любой метод, возвращающий некоторое значение. Следует также отметить, что даже при том, что прием
             внедрения методов позволяет замещать их реализации, нет никакой возможности изменить сигнатуру
             метода. Типы параметров и возвращаемого значения должны оставаться такими, какие они есть. В
             случае с элементом <lookup-method> это означает, что атрибут bean должен ссылаться на компонент,
             тип которого совместим с типом значения, возвращаемого методом ( Instrument в предыдущем примере).  ====-->


    <!--=============================================================================================================-->
    <!--==================================== Внедрение не-Spring компонентов ========================================-->
    <!--=============================================================================================================-->

    <!--==== Не все объекты, имеющиеся в приложении, создаются контейнером Spring. Рассмотрим следующие
             возможные ситуации:
                    Обычно JSP-теги реализуются веб-контейнером, в рамках которого выполняется приложение.
                     Если JSP-тег нуждается во взаимодействии с какими-то другими объектами, он должен
                     создавать их сам.
                    Доменные объекты , которые типично создаются во время выполнения инструментами ORM (такими
                     как Hibernate или iBATIS ). В расширенной доменной модели доменные объекты обладают и
                     информацией о состоянии, и поведением. Но если нет возможности внедрить служебные объекты
                     в доменные объекты, то доменные объекты должны создавать их сами или иметь собственную
                     реализацию логики их поведения.                                                             ====-->



    <bean id="pianist"
          class="springidol.Instrumentalist"
          abstract="true">
        <property name="song" value="Chopsticks" />
        <property name="instrument">
            <bean class="springidol.Piano" />
        </property>
    </bean>

    <!--==== Как рассказывалось выше, атрибут abstract со значением true сообщает фреймворку Spring, что для
             этого компонента не требуется создавать экземпляр класса. Этот прием часто используется при
             объявлении родительских компонентов, которые будут расширяться дочерними компонентами. Но в
             данном случае мы просто указываем фреймворку Spring, что компонент pianist не должен создаваться
             им, – это будет сделано без участия фреймворка. На самом деле компонент pianist служит для Spring
             лишь шаблоном настройки экземпляров Instrumentalist , созданных за его пределами. После определения
             шаблона необходим некоторый способ связывания его с классом Instrumentalist . Для этого нужно
             аннотировать класс Instrumentalist аннотацией @Configurable.


             Аннотация @Configurable играет двоякую роль:
                     во-первых, она показывает, что экземпляр класса Instrumentalist может быть сконфигурирован
                      фреймворком Spring, даже при создании за его пределами;
                     она также связывает класс Instrumentalist и компонент с идентификатором pianist . При
                      настройке экземпляра класса Instrumentalist фреймворк Spring будет использовать
                      определение компонента pianist как шаблон.
            Но как Spring узнает, как настраивать компоненты с аннотацией @Configurable ? За это отвечает
            следующий элемент в конфигурации Spring: <aop:spring-configured />     ====-->
































</beans>
